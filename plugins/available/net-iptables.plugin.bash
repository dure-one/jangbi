## \brief iptables firewall configurations. <div style="text-align: right"> group:**net** | runtype:**systemd** | deps: **-** | port: **-**</div><br/>
## \desc 
## [Iptables](https://netfilter.org/projects/iptables/index.html){:target="_blank"} is a user-space utility for configuring Linux kernel firewall.
# It provides packet filtering, network address translation (NAT), and packet mangling capabilities.
# We use it for comprehensive network security and traffic control in Jangbi.
## 
## # Jangbi Configs
## ```bash title="/opt/jangbi/.config"
## RUN_NET_IPTABLES=1 # enable iptables firewall
## IPTABLES_MODE="Gateway" # Gateway, Tunnelonly, Client
## ```
## # Check if running
## ```bash title="bash command"
## $ iptables -L -n
## Chain INPUT (policy ACCEPT)
## target     prot opt source               destination
## $ iptables -t nat -L -n
## Chain PREROUTING (policy ACCEPT)
## ```
## # Current Configuration
## Current configuration is stored in `/etc/iptables/`. it is generated by `net-iptables configgen` command on install.
## You can edit it manually and not run install or configapply commands to keep current configurations.
## ```bash title="/etc/iptables/rules.v4"
## --8<-- "./configs/iptables/iptables.iptables"
## ```

# shellcheck shell=bash
cite about-plugin a
about-plugin 'iptables install configurations.'

# filter(INPUT FORWARD OUTPUT)
# nat(PREROUTING INPUT OUTPUT POSTROUTING)
# mangle(PREROUTING INPUT FORWARD OUTPUT POSTROUTING)
# raw(PREROUTING OUTPUT)
# security(INPUT FORWARD OUTPUT)

# https://ipset.netfilter.org/iptables-extensions.man.html#lbAP
# https://gist.github.com/egernst/2c39c6125d916f8caa0a9d3bf421767a
# https://andrewpage.tistory.com/38
# https://postfiles.pstatic.net/MjAxOTExMjZfMjA1/MDAxNTc0NzI0NDk2OTQ1.MBOrliBXqYltD27U5rpO9EqEKEOh2_ERcGvTDf7c3gQg.XlVAiDi6coPTftr1C7RbvBQkIrEYd4x2d-N7spdrKf4g.PNG.firstpw/2.png?type=w3840
# https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html#RETURNTARGET
# https://ipset.netfilter.org/ipset.man.html
# iptables order2
#                                    netfilter hooks
#
#                                   +-----------> local +-----------+
#                                   |             process           |
#                                   |                               |
#                                   |                               |
#                                   |                               |
#                                   |                               |
#                                   |                               |
#                                   |                               v
#   MANGLE            +-------------+--------+
#   FILTER            |                      |               +----------------------+    RAW
#   SECURITY          |        input         |               |                      |    conntrack
#   SNAT              |                      |               |     output           |    MANGLE
#                     +------+---------------+               |                      |    DNAT
#                            ^                               +-------+--------------+    routing
#                            |                                       |                   FILTER
#                            |                                       |                   SECURITY
#                            |            +---------------------+    |         +-------------+
#      +-----------+                      |                     |    +-------> |             |
# +--> |pre routing+----  route    -----> |      forward        |              |post routing +---->
#      |           |      lookup          |                     +------------> |             |
#      +-----------+                      +---------------------+              +-------------+
#
#      RAW                                       MANGLE                         MANGLE
#      conntrack                                 FILTER                         SNAT
#      MANGLE                                    SECURITY
#      DNAT
#      routing

# bridge filters(ebtables)
#                                                       +-----------> local +-----------+
#                                                       |                               |
#                                                       |                               |
#                                                       |                               |
#                                                       |                               |
#                                                       |                               |
#                                                       |                               |
#                                                       |                               v
#                                         +-------------+--------+
#                                         |                      |               +----------------------+
#                                         |        input         |               |                      |
#                                         |                      |               |     output           |
#                                         +------+---------------+               |                      |
#                                                ^                               +-------+--------------+
#                                                |                                       |
#                                                |                                       |
#                                                |            +---------------------+    |         +-------------+
#  ---------------         +-----------+                      |                     |    +-------> |             |
#   |  brouting   |    --> |pre routing+----  route    -----> |      forward        |              |post routing +---->
#   |             |        |           |      lookup          |                     +------------> |             |
#   --------------         +-----------+                      +---------------------+              +-------------+

function net-iptables {
    about 'iptables install configurations'
    group 'postnet'
    runtype 'systemd'
    deps  ''
    param '1: command'
    param '2: params'
    example '$ net-iptables subcommand'
    local PKGNAME="iptables"
    local DMNNAME="net-iptables"
    BASH_IT_LOG_PREFIX="net-iptables: "
    # IPTABLES_PORTS="${IPTABLES_PORTS:-""}"
    if _check_config_reload; then
        _root_only || exit 1
        _distname_check || exit 1
    fi

    if [[ $# -eq 1 ]] && [[ "$1" = "help" ]]; then
        __net-iptables_help "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "install" ]]; then
        __net-iptables_install "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "uninstall" ]]; then
        __net-iptables_uninstall "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "download" ]]; then
        __net-iptables_download "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "disable" ]]; then
        __net-iptables_disable "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "configgen" ]]; then
        __net-iptables_configgen "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "configapply" ]]; then
        __net-iptables_configapply "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "check" ]]; then
        __net-iptables_check "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "run" ]]; then
        __net-iptables_run "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "build" ]]; then
        __net-iptables_build "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "watch" ]]; then
        __net-iptables_watch "$2"
    else
        __net-iptables_help
    fi
}  

## \usage net-iptables help|install|uninstall|download|disable|configgen|configapply|check|run|build|watch
## $ net-iptables install - install iptables firewall
## $ net-iptables uninstall - uninstall iptables firewall
## $ net-iptables download - download iptables package files to pkg dir
## $ net-iptables disable - disable iptables plugin
## $ net-iptables configgen - generate iptables configuration files
## $ net-iptables configapply - apply iptables configuration files
## $ net-iptables check - check iptables plugin status
## $ net-iptables run - run iptables firewall rules
## $ net-iptables build - build iptables rule files
## $ net-iptables watch - watch iptables traffic
## $ net-iptables help - show this help message
function __net-iptables_help {
    echo -e "Usage: net-iptables [COMMAND]\n"
    echo -e "Helper to iptables install configurations.\n"
    echo -e "Commands:\n"
    echo "   help                       Show this help message"
    echo "   install                    Install os iptables"
    echo "   uninstall                  Uninstall installed iptables"
    echo "   download                   download pkg files to pkg dir"
    echo "   disable                    Disable iptables service"
    echo "   configgen                  Configs Generator"
    echo "   configapply                Apply Configs"
    echo "   check                      Check vars available"
    echo "   run                        do task at bootup"
    echo "   build                      rebuild iptables by configs"
    echo "   watch                      watch nftables"
}

function __net-iptables_install {
    log_debug "Installing ${DMNNAME}..."
    export DEBIAN_FRONTEND=noninteractive
    if [[ ${INTERNET_AVAIL} -gt 0 ]]; then
        [[ $(find /etc/apt/sources.list.d|grep -c "extrepo_debian_official") -lt 1 ]] && extrepo enable debian_official
        [[ $(stat /var/lib/apt/lists -c "%X") -lt $(date -d "1 day ago" +%s) ]] && apt update -qy
        apt install -qy nftables iptables arptables net-tools ipset iprange || log_error "${DMNNAME} online install failed."
    else
        local filepat="./pkgs/nftables*.deb"
        local pkglist="./pkgs/nftables.pkgs"
        [[ $(find ${filepat}|wc -l) -lt 1 ]] && log_error "${DMNNAME} pkg file not found."
        pkgslist_down=()
        while read -r pkg; do
            [[ $pkg ]] && pkgslist_down+=("./pkgs/${pkg}*.deb")
        done < ${pkglist}
        # shellcheck disable=SC2068
        apt install -qy ${pkgslist_down[@]} || log_error "${DMNNAME} offline install failed."
    fi
    if ! __net-iptables_configgen; then # if gen config is different do apply
        __net-iptables_configapply
        rm -rf /tmp/iptables
    fi
    rm -rf /tmp/${PKGNAME}.diff
}

function __net-iptables_configgen { # config generator and diff
    [[ -z ${PKGNAME} ]] && log_error "please run this function from ${DMNNAME} cmd." && return 1
    rm -rf /tmp/${PKGNAME} 1>/dev/null 2>&1
    mkdir -p /tmp/${PKGNAME} /etc/${PKGNAME} 1>/dev/null 2>&1
    # cp ./configs/${PKGNAME}/* /tmp/${PKGNAME}/

    __net-iptables_build # after build, /etc/nftables.conf /etc/iptables/nftables.conf have same contents
    diff -Naur /etc/${PKGNAME} /tmp/${PKGNAME} > /tmp/${PKGNAME}.diff
    [[ $(stat -c %s /tmp/${PKGNAME}.diff) = 0 ]] && return 0 || return 1
}

function __net-iptables_configapply {
    [[ ! -f /tmp/${PKGNAME}.diff ]] && log_error "/tmp/${PKGNAME}.diff file doesnt exist. please run configgen."
    local dtnow=$(date +%Y%m%d_%H%M%S)
    [[ -d "/etc/${PKGNAME}" ]] && cp -rf "/etc/${PKGNAME}" "/etc/.${PKGNAME}.${dtnow}"
    pushd /etc/${PKGNAME} 1>/dev/null 2>&1
    patch -i /tmp/${PKGNAME}.diff
    popd 1>/dev/null 2>&1
    rm /tmp/${PKGNAME}.diff
    return 0
}

function __net-iptables_download {
    _download_apt_pkgs "nftables iptables arptables net-tools ipset iprange" || log_error "${DMNNAME} download failed."
    return 0
}

function __net-iptables_uninstall { 
    log_debug "Uninstalling ${DMNNAME}..."
    systemctl stop nftables
    systemctl disable nftables
}

function __net-iptables_disable {
    log_debug "Disabling ${DMNNAME}..."
    systemctl stop nftables
    systemctl disable nftables
    return 0
}

function __net-iptables_check { # running_status: 0 running, 1 installed, running_status 5 can install, running_status 10 can't install, 20 skip
    running_status=0
    log_debug "Checking ${DMNNAME}..."

    # check package file exists
    [[ $(find ./pkgs/nftables*.pkgs|wc -l) -lt 1 ]] && \
        log_info "nftables package file does not exist." && [[ $running_status -lt 15 ]] && running_status=15
    # check cmd exists
    [[ $(which ipcalc-ng|wc -l) -lt 1 ]] && \
        log_error "ipcacl-ng command does not exist. please install it." && [[ $running_status -lt 10 ]] && running_status=10
    # check global variable
    [[ -z ${RUN_NET_IPTABLES} ]] && \
        log_error "RUN_NET_IPTABLES variable is not set." && [[ $running_status -lt 10 ]] && running_status=10
    [[ ${RUN_NET_IPTABLES} != 1 ]] && \
        log_error "RUN_NET_IPTABLES is not enabled." && __net-iptables_disable && [[ $running_status -lt 20 ]] && running_status=20
    # check package iptables
    [[ $(dpkg -l|awk '{print $2}'|grep -c iptables) -lt 1 ]] && \
        log_info "iptables is not installed." && [[ $running_status -lt 5 ]] && running_status=5
    # check if running
    [[ $(systemctl status nftables 2>/dev/null|awk '{ print $2 }'|grep -c inactive) -lt 1 ]] && \
        log_info "nftables is running." && [[ $running_status -lt 1 ]] && running_status=1

    return 0
}

function __net-iptables_run {
    # # echo ""> /etc/nftables.conf # prevent not running because of xttables for nftables
    # systemctl restart nftables
    # systemctl status nftables && return 0 || \
    #     log_error "nftables failed to run." && return 1
    if ! __net-iptables_configgen; then # if gen config is different do apply
        __net-iptables_configapply
        rm -rf /tmp/iptables
    fi
    rm -rf /tmp/${PKGNAME}.diff
    return 0
}

function __net-iptables_watch {
    watch -n 1 'nft list ruleset |grep -v 0\ drop|grep -v }'
}

function __net-iptables_build {
    # read config apply
    # EMPTY RULES
    nft flush ruleset

    # GET VARs
    local wanip lanip wlanip
    wanip=$(_get_ip_of_infmark "WAN" || echo "")
    [[ -z ${wanip} ]] && wanip="127.0.0.1"
    lanip=$(_get_ip_of_infmark "LAN" || echo "")
    [[ -z ${lanip} ]] && lanip="127.0.0.1"
    wlanip=$(_get_ip_of_infmark "WLAN" || echo "")
    [[ -z ${wlanip} ]] && wlanip="127.0.0.1"
    
    #
    # ARP RULES
    #
    # IPTABLES_IPTABLES_WHMACADDR
    [[ ${#IPTABLES_WHMACADDR[@]} -gt 0 ]] && __net-iptables_mangle_all_both_macwhitelist "${waninf}" "${GW_MAC}" # targetinf macaddrs
    # IPTABLES_GWMAC
    log_debug "iptables_mangle_ext_both_gwmaconly"
    [[ ${IPTABLES_GWMAC} -gt 0 ]] && __net-iptables_mangle_ext_both_gwmaconly
    # IPTABLES_ARPALLINFS # Arptables : Allow all other network except gateway
    log_debug "iptables_mangle_all_both_arpallinfs"
    [[ ${IPTABLES_ARPALLINFS} -gt 0 ]] && __net-iptables_mangle_all_both_arpallinfs

    #
    # BASE RULES
    #
    # run basesetup
    __net-iptables_filter_all_both_basesetup 

    # IPTABLES_ANTISPOOFING=1 # Anti-spoofing protection
    log_debug "iptables_filter_all_both_antispoofing"
    [[ ${IPTABLES_ANTISPOOFING} -gt 0 ]] && __net-iptables_filter_all_both_antispoofing
    # IPTABLES_DROPCASTS=1 # Drop broadcast/multicast/anycast packets
    log_debug "iptables_filter_all_both_dropcasts"
    [[ ${IPTABLES_DROPCASTS} -gt 0 ]] && __net-iptables_filter_all_both_dropcasts
    # IPTABLES_DROPICMP=0 # Drop icmp packets
    log_debug "iptables_filter_all_both_dropicmp"
    [[ ${IPTABLES_DROPICMP} -gt 0 ]] && __net-iptables_filter_all_both_dropicmp
    # IPTABLES_ALLOWED_PORTS="80,443,8080" # service-specific rules
    log_debug "iptables_filter_all_both_servicerules"
    [[ ${#IPTABLES_ALLOWED_PORTS[@]} -gt 0 ]] && __net-iptables_filter_all_both_servicerules
    # IPTABLES_NOISE_REDUCTION=1 # block netbios, smb without logging
    log_debug "iptables_filter_all_both_noisereduction"
    [[ ${IPTABLES_NOISE_REDUCTION} -gt 0 ]] && __net-iptables_filter_all_both_noisereduction
    # IPTABLES_DROP_UPNP=1 # Drop UPnP packets
    log_debug "iptables_filter_all_both_dropupnp"
    [[ ${IPTABLES_DROP_UPNP} -gt 0 ]] && __net-iptables_filter_all_both_dropupnp
    # IPTABLES_REJECT_AUTH=1 # service-specific rules
    log_debug "iptables_filter_all_both_rejectauth"
    [[ ${IPTABLES_REJECT_AUTH} -gt 0 ]] && __net-iptables_filter_all_both_rejectauth

    #
    # NET RULES
    #
    # IPTABLES_DROP_ICMP=1
    log_debug "iptables_mangle_all_both_dropicmp"
    [[ ${IPTABLES_DROP_ICMP} -gt 0 ]] && __net-iptables_mangle_all_both_dropicmp
    # IPTABLES_DROP_NON_SYN=1
    log_debug "iptables_mangle_all_both_dropnonsyn"
    [[ ${IPTABLES_DROP_NON_SYN} -gt 0 ]] && __net-iptables_mangle_all_both_dropnonsyn
    # IPTABLES_DROP_SPOOFING=1
    log_debug "iptables_mangle_all_both_dropspoofing"
    [[ ${IPTABLES_DROP_SPOOFING} -gt 0 ]] && __net-iptables_mangle_all_both_dropspoofing
    # IPTABLES_LIMIT_MSS=1
    log_debug "iptables_mangle_all_both_limitmss"
    [[ ${IPTABLES_LIMIT_MSS} -gt 0 ]] && __net-iptables_mangle_all_both_limitmss
    # IPTABLES_INVALID_TCPFLAG=1
    log_debug "iptables_raw_all_both_dropinvtcpflag"
    [[ ${IPTABLES_INVALID_TCPFLAG} -gt 0 ]] && __net-iptables_raw_all_both_dropinvtcpflag
    # IPTABLES_BLACK_NAMELIST=""
    log_debug "iptables_filter_all_both_ipblacklist"
    [[ ${#IPTABLES_BLACK_NAMELIST[@]} -gt 0 ]] && __net-iptables_filter_all_both_ipblacklist

    #
    # HOST RULES
    #    

    # PORT FORWARDING WAN->LAN
    # IPTABLES_PORTFORWARD="8090:192.168.0.1:8090,8010:192.168.0.1:8010"
    log_debug "iptables_nat_ext_both_portforward"
    [[ ${#IPTABLES_PORTFORWARD[@]} -gt 0 ]] && __net-iptables_nat_ext_both_portforward

    # DMZ SETTINGS WAN->HOST
    # IPTABLES_DMZ="192.168.0.1" IPTABLES_SUPERDMZ=1
    log_debug "iptables_nat_ext_both_dmzsdmz"
    [[ ${#IPTABLES_DMZ[@]} -gt 0 ]] && __net-iptables_nat_ext_both_dmzsdmz

    # MASQUERADE WAN->NET
    # IPTABLES_MASQ="LAN<WAN,LAN1<WAN"
    if [[ -n ${IPTABLES_MASQ} ]]; then
        IPTABLES_MASQ=$(_trim_string ${IPTABLES_MASQ})
        IFS=$',' read -d "" -ra MASQROUTES <<< "${IPTABLES_MASQ}" # split
        for((j=0;j<${#MASQROUTES[@]};j++)){
            local frominf="" toinf="" fromnet="" tonet=""
            IFS=$'<' read -d "" -ra masqinfs <<< "${MASQROUTES[j]}"
            frominf=$(_get_inf_of_infmark "${masqinfs[0]}" || echo "")
            toinf=$(_get_inf_of_infmark "$(_trim_string ${masqinfs[1]})" || echo "")
            if [[ $(_trim_string ${masqinfs[0]}) = "LAN" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "WLAN" && $(_trim_string ${masqinfs[1]}) = "WAN"  ]]; then
                fromnet=$(ipcalc-ng ${JB_WLAN}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN0" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN0}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN1" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN1}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN2" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN2}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN3" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN3}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN4" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN4}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN5" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN5}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN6" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN6}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN7" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN7}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN8" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN8}|grep Network:|cut -f2)
            elif [[ $(_trim_string ${masqinfs[0]}) = "LAN9" && $(_trim_string ${masqinfs[1]}) = "WAN" ]]; then
                fromnet=$(ipcalc-ng ${JB_LAN9}|grep Network:|cut -f2)
            fi

            if [[ -n ${frominf} && -n ${toinf} ]]; then
                log_debug "iptables_filternat_all_both_masquerade frominf:${frominf} fromnet:${fromnet} toinf:${toinf}"
                __net-iptables_filternat_all_both_masquerade  "${frominf}" "${fromnet}" "${toinf}" # laninf lannet waninf
            else
                log_error "iptables_filternat_all_both_masquerade ${IPTABLES_MASQ} ${MASQROUTES[j]} frominf:${frominf} fromnet:${fromnet} toinf:${toinf}"
                continue
            fi
        }
    fi
    # nft --check --file /tmp/iptables/nftables.conf
    # IPTABLES_SNAT="LAN<WAN,LAN1<WAN"
    # [[ ${IPTABLES_SNAT} -gt 0 ]] && __net-iptables_filternat_all_both_snat # laninf lannet waninf wanip
    iptables-save > /tmp/iptables/iptables.iptables
    nft list ruleset > /tmp/iptables/nftables.conf

    log_debug "iptables build done."
    return 0
}

# MODES : Gateway, TunnelOnly, Client
# TABLES : filter(IFO), nat(PIOP), mangle(IFP), raw(PO), security(IOF) https://gist.github.com/egernst/2c39c6125d916f8caa0a9d3bf421767a
# PREFIX : int/ext/all inc/oug/both contents

## \function Arptables : MAC Whitelisting
## \function-description Add mac address for target interface(LO/LAN/WAN/WLAN/ALL) to whitelist.<br/>
## (config)```IPTABLES_WHMACADDR="LAN-aa:bb:cc:dd:ee,WAN-ab:cd:be:c0:a1"```<br/>
## (command)```arptables -A INPUT -i "${targetinf}" --source-mac "${infmac[1]}" -j ACCEPT```<br/>
function __net-iptables_mangle_all_both_macwhitelist {
    local funcname targetinf macaddrs
    funcname="mab_macwhitelist"
    targetinf=$(_trim_string "$1")
    macaddrs=$(_trim_string "$2")

    [[ ${#targetinf} -lt 1 ]] && log_error "${funcname}: targetinf is not set" && return 1
    [[ ${#macaddrs} -lt 1 ]] && log_error "${funcname}: macaddrs is not set" && return 1

    IFS=$',' read -d "" -ra blockconf <<< "${macaddrs}" # split
    for((j=0;j<${#blockconf[@]};j++)){
        local targetinf infmac
        IFS=$'-' read -d "" -ra infmac <<< "${blockconf[j]}" # split
        [[ ${#infmac[@]} != 2 ]] && log_error "${funcname}: wrong params(${blockconf[j]})."
        [[ ${infmac[0]} = "WAN" ]] && targetinf=${waninf}
        [[ ${infmac[0]} = "LAN" ]] && targetinf=${laninf}
        [[ ${infmac[0]} = "WLAN" ]] && targetinf=${wlaninf}
        arptables -A INPUT -i "${targetinf}" --source-mac "${infmac[1]}" -j ACCEPT
        log_debug "arptables -A INPUT -i ${targetinf} --source-mac ${infmac[1]} -j ACCEPT"
    }
    [[ $(arptables -S|grep -c "INPUT DROP") -lt 1 ]] && arptables -P INPUT DROP
}

## \function Arptables : Allow Gateway MAC on WAN
## \function-description Add gateway mac address to WAN mac whitelist.<br/>
## (config)```IPTABLES_GWMAC=1```<br/>
## (command)```arptables -A INPUT -i "${targetinf}" --source-mac "${gwmac}" -j ACCEPT```<br/>
function __net-iptables_mangle_ext_both_gwmaconly {
    local funcname targetinf gwip gwmac
    funcname="meb_gwmaconly"
    
    targetinf=$(route|grep default|awk '{print $8}') # net-tools
    targetinf=$(_trim_string ${targetinf})
    gwip=$(routel|grep default|awk '{print $2}') # net-tools
    gwip=$(_trim_string ${gwip})
    gwmac=$(cat /proc/net/arp|grep "${gwip}"|awk '{print $4}')
    gwmac=$(_trim_string ${gwmac})

    [[ ${#targetinf} -lt 1 ]] && log_error "${funcname}: targetinf is not set" && return 1
    [[ ${#gwip} -lt 1 ]] && log_error "${funcname}: gwip is not set" && return 1
    [[ ${#gwmac} -lt 1 ]] && log_error "${funcname}: gwmac is not set" && return 1

    arptables -A INPUT -i "${targetinf}" --source-mac "${gwmac}" -j ACCEPT
    log_debug "arptables -A INPUT -i ${targetinf} --source-mac ${gwmac} -j ACCEPT"
    [[ $(arptables -S|grep -c "INPUT DROP") -lt 1 ]] && arptables -P INPUT DROP
}

## \function Arptables : Allow all other network except gateway
## \function-description Allow all ARP except gateway interface.<br/>
## (config)```IPTABLES_ARPALLINFS=1```<br/>
## (command)```arptables -A INPUT -i "${allinfx[i]}" -j ACCEPT```<br/>
function __net-iptables_mangle_all_both_arpallinfs {
    local funcname gwinf allinfx infs
    funcname="mab_arpallinfs"

    gwinf=$(route|grep default|awk '{print $8}') # net-tools
    gwinf=$(_trim_string ${gwinf})
    log_debug "check network interfaces for arptables"

    infs=$(cat /proc/net/dev|grep :|awk '{print $1}'|sed 's/://g')
    IFS=$'\n' read -rd '' -a allinfx <<<"$infs"
    for((i=0;i<${#allinfx[@]};i++)){ 
        if [[ ${allinfx[i]} = "lo" ]]; then
            log_debug "skip lo interface for arptables"
            continue
        fi
        if [[ ${allinfx[i]} = ${gwinf} ]]; then # except gateway interface
            log_debug "skip ${gwinf} interface for arptables"
            continue
        fi
        arptables -A INPUT -i "${allinfx[i]}" -j ACCEPT
        log_debug "arptables -A INPUT -i ${allinfx[i]} -j ACCEPT"
    }
    [[ $(arptables -S|grep -c "INPUT DROP") -lt 1 ]] && arptables -P INPUT DROP
}

## \function Mangle Prerouting : Drop ICMP
## \function-description Drop ICMP packets in mangle table prerouting chain.<br/>
## (config)```IPTABLES_DROP_ICMP=1```<br/>
## (command)```iptables -t mangle -A PREROUTING -p icmp -m comment --comment ${funcname} -j DROP```<br/>
function __net-iptables_mangle_all_both_dropicmp {
    local funcname="mab_dropicmp"

    IPTABLE="PREROUTING -p icmp -m comment --comment ${funcname} -j DROP"
    log_debug "${IPTABLE}"
    iptables -t mangle -S | grep "${funcname}" || iptables -t mangle -A ${IPTABLE}
}

## \function Mangle Prerouting : Drop Invalid State
## \function-description Drop packets with invalid connection state in mangle table prerouting chain.<br/>
## (config)```IPTABLES_DROP_INVALID_STATE=1```<br/>
## (command)```iptables -t mangle -I PREROUTING -p all -m conntrack --ctstate INVALID -m comment --comment ${funcname} -j DROP```<br/>
function __net-iptables_mangle_all_both_dropinvalidstate {
    local funcname="mab_dropinvalidstate"

    IPTABLE="PREROUTING -p all -m conntrack --ctstate INVALID -m comment --comment ${funcname} -j DROP"
    log_debug "${IPTABLE}"
    iptables -t mangle -S | grep "${funcname}" || iptables -t mangle -I ${IPTABLE}
}

## \function Mangle Prerouting : Drop new non-SYN TCP Packets
## \function-description Drop new TCP packets that do not have SYN flag set in mangle table prerouting chain.<br/>
## (config)```IPTABLES_DROP_NON_SYN=1```<br/>
## (command)```iptables -t mangle -I PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -m comment --comment ${funcname} -j DROP```<br/>
function __net-iptables_mangle_all_both_dropnonsyn {
    local funcname="mab_dropnonsyn"

    IPTABLE="PREROUTING -p tcp ! --syn -m conntrack --ctstate NEW -m comment --comment ${funcname} -j DROP"
    log_debug "${IPTABLE}"
    iptables -t mangle -S | grep "${funcname}" || iptables -t mangle -I ${IPTABLE}
}

## \function Mangle Prerouting : Drop Spoofing Packets
## \function-description Drop spoofing packets from specified networks except allowed routing in mangle table prerouting chain.<br/>
## (config)```IPTABLES_DROP_SPOOFING=1 IPTABLES_DROP_SPOOFING_TARINF=WAN IPTABLES_DROP_SPOOFING_NET="224.0.0.0/3,169.254.0.0/16,172.16.0.0/12,192.0.2.0/24,192.168.0.0/16,10.0.0.0/8,0.0.0.0/8,240.0.0.0/5,127.0.0.0/8"```<br/>
## (command)```iptables -t mangle -A PREROUTING -s ${iptables_block_ip} -i ${tarinf} -m comment --comment ${funcname}_block_${j} -j DROP```<br/>
function __net-iptables_mangle_all_both_dropspoofing {
    local funcname="mab_dropspoofing"
    local tarinf tarnets
    tarinf=$(_trim_string "${IPTABLES_DROP_SPOOFING_TARINF}")
    tarnets=$(_trim_string "${IPTABLES_DROP_SPOOFING_NET}")
    
    [[ ${#tarinf} -lt 1 ]] && log_error "${funcname}: tarinf is not set" && return 1
    [[ ${#tarnets} -lt 1 ]] && log_error "${funcname}: tarnets is not set" && return 1

    IFS=$'\n' read -d "" -ra routing_allow_list <<< "$(routel|grep /|grep -v 127.0.0.0/8|cut -d" " -f1)" # split
    routing_allow_list+=("127.0.0.1/29") # add localhost range 127.0.0.1-14 for anydnsdqy and dnsmasq
    IFS=$',' read -d "" -ra routing_block_list <<< "${tarnets}" # split
    for((j=0;j<${#routing_block_list[@]};j++)){
        __bp_trim_whitespace iptables_block_ip "${routing_block_list[j]}"
        for((k=0;k<${#routing_allow_list[@]};k++)){
            __bp_trim_whitespace iptables_allow_ip "${routing_allow_list[k]}"
            # log_debug "${iptables_allow_ip} ${iptables_block_ip}"
            ALMINIP=$(_ip2conv "$(ipcalc-ng "${iptables_allow_ip}"|grep HostMin:|cut -f2)")
            ALMAXIP=$(_ip2conv "$(ipcalc-ng "${iptables_allow_ip}"|grep HostMax:|cut -f2)")
            BLMINIP=$(_ip2conv "$(ipcalc-ng "${iptables_block_ip}"|grep HostMin:|cut -f2)")
            BLMAXIP=$(_ip2conv "$(ipcalc-ng "${iptables_block_ip}"|grep HostMax:|cut -f2)")
            if [[ ${ALMINIP} -gt ${BLMINIP} && ${ALMAXIP} -lt ${BLMAXIP} ]]; then
                log_debug "allowing ip ${iptables_allow_ip}"
                IPTABLE="PREROUTING -s ${iptables_allow_ip} -m comment --comment ${funcname}_allow_${j}${k} -j ACCEPT"
                log_debug "${IPTABLE}"
                iptables -t mangle -S | grep "${funcname}_allow_${j}${k}" || iptables -t mangle -A ${IPTABLE}
            fi
        }
        log_debug "blocking ip ${iptables_block_ip}"
        [[ ${#tarinf[@]} -gt 0 ]] && IPTABLE="PREROUTING -s ${iptables_block_ip} -i ${tarinf} -m comment --comment ${funcname}_block_${j} -j DROP"
        [[ ${#tarinf[@]} -eq 0 ]] && IPTABLE="PREROUTING -s ${iptables_block_ip} -m comment --comment ${funcname}_block_${j} -j DROP"
        log_debug "${IPTABLE}"
        iptables -t mangle -S | grep "${funcname}_block_${j}" || iptables -t mangle -A ${IPTABLE}
    }
}

## \function Mangle Prerouting : Limit MSS
## \function-description Drop TCP packets with MSS outside allowed range in mangle table prerouting chain.<br/>
## (config)```IPTABLES_LIMIT_MSS=1```<br/>
## (command)```iptables -t mangle -I PREROUTING -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss ${mss} -m comment --comment ${funcname} -j DROP```<br/>
function __net-iptables_mangle_all_both_limitmss {
    local funcname="mab_limitmss"
    local mss="536:65535" # port range

    IPTABLE="PREROUTING -p tcp -m conntrack --ctstate NEW -m tcpmss ! --mss "${mss}" -m comment --comment ${funcname} -j DROP"
    log_debug "${IPTABLE}"
    iptables -t mangle -S | grep "${funcname}" || iptables -t mangle -I ${IPTABLE}
}

## \function Filter/NAT Forward/Postrouting Masquerade
## \function-description Set up masquerading between internal and external interfaces with proper forwarding rules.<br/>
## (config)```IPTABLES_MASQ?="WLAN<WAN|LAN<WAN"```<br/>
## (command)```iptables -t nat -A POSTROUTING ! -d ${fromnet} -o ${toinf} -m comment --comment ${funcname}_${j}_masq -j MASQUERADE```<br/>
function __net-iptables_filternat_all_both_masquerade {
    local funcname="fab_masquerade"
    local frominf
    frominf=$(_trim_string "$1")
    local fromnet
    fromnet=$(_trim_string "$2")
    local toinf
    toinf=$(_trim_string "$3")

    [[ ${#frominf} -lt 1 ]] && log_error "${funcname}: frominf is not set" && return 1
    [[ ${#fromnet} -lt 1 ]] && log_error "${funcname}: fromnet is not set" && return 1
    [[ ${#toinf} -lt 1 ]] && log_error "${funcname}: toinf is not set" && return 1

    IPTABLE="FORWARD -i ${frominf} -o ${toinf} -m comment --comment ${funcname}_${j}_filter1 -j ACCEPT"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_${j}_filter1" || iptables -t filter -A ${IPTABLE}
    IPTABLE="FORWARD -i ${toinf} -o ${frominf} -m state --state ESTABLISHED,RELATED -m comment --comment ${funcname}_${j}_filter2 -j ACCEPT"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_${j}_filter2" || iptables -t filter -A ${IPTABLE}
    IPTABLE="POSTROUTING ! -d ${fromnet} -o ${toinf} -m comment --comment ${funcname}_${j}_masq -j MASQUERADE"
    log_debug "${IPTABLE}"
    iptables -t nat -S | grep "${funcname}_${j}_masq" || iptables -t nat -A ${IPTABLE}
    # iptables -t nat -A POSTROUTING -o eth0 -j SNAT --to-source 192.0.2.123
}

# Filter/NAT Forward/Postrouting SNAT
# IPTABLES_SNAT?="WLAN<WAN,LAN<WAN" # enP3p49s0>enP4p65s0(not implemented) # laninf lannet waninf wanip
#function __net-iptables_filternat_all_both_snat {
#    local funcname="fnab_masquerade"
#    local frominf="$1" # internal network
#    local fromnet="$2" # internal network
#    local toinf="$4" # external network
#    local toip="$5" # external ip
#
#    IPTABLE="FORWARD -i ${frominf} -o ${toinf} -m comment --comment ${funcname}_${j}_filter1 -j ACCEPT"
#    iptables -t filter -S | grep "${funcname}_${j}_filter1" || iptables -t filter -A ${IPTABLE}
#    IPTABLE="FORWARD -i ${toinf} -o ${frominf} -m state --state ESTABLISHED,RELATED -m comment --comment ${funcname}_${j}_filter2 -j ACCEPT"
#    iptables -t filter -S | grep "${funcname}_${j}_filter2" || iptables -t filter -A ${IPTABLE}
#    IPTABLE="POSTROUTING ! -d ${fromnet} -o ${toinf} -m comment --comment ${funcname}_${j}_snat -j SNAT --to-source ${toip}"
#    iptables -t nat -S | grep "${funcname}_${j}_snat" || iptables -t nat -A ${IPTABLE}
#}

## \function DMZ - after portforward, SDMZ - prior to portforward
## \function-description Set up DMZ (Demilitarized Zone) routing to forward all traffic to specified internal host.<br/>
## (config)```IPTABLES_DMZ="192.68.79.10" IPTABLES_SUPERDMZ=1```<br/>
## (command)```iptables -t nat -A PREROUTING -p ALL -i ${waninf} -j DNAT --to-destination ${dmzip} -m comment --comment ${funcname}_dmznat```<br/>
function __net-iptables_nat_ext_both_dmzsdmz {
    local funcname waninf laninf dmzip sdmz
    funcname="neb_dmzsdmz"
    waninf=$(_get_inf_of_infmark "WAN")
    laninf=$(_get_inf_of_infmark "LAN")
    dmzip=$(_trim_string "${IPTABLES_DMZ}")
    sdmz=$(_trim_string "${IPTABLES_SUPERDMZ}")

    [[ ${#waninf} -lt 1 ]] && log_error "${funcname}: waninf is not set" && return 1
    [[ ${#laninf} -lt 1 ]] && log_error "${funcname}: laninf is not set" && return 1
    [[ ${#dmzip} -lt 1 ]] && log_error "${funcname}: dmzip is not set" && return 1
    [[ ${#sdmz} -lt 1 ]] && log_error "${funcname}: sdmz is not set" && return 1

    local ruleaddoverinsert="-A"
    [[ ${sdmz} -eq "1" ]] && ruleaddoverinsert="-I"
    # dmz input rule1
    IPTABLE="INPUT -p ALL -i ${laninf} -d ${dmzip} -j ACCEPT -m comment --comment ${funcname}_dmzinput"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_dmzinput" || iptables -t filter ${ruleaddoverinsert} ${IPTABLE}
    # dmz filter forward network
    IPTABLE="FORWARD -i ${laninf} -o ${waninf} -j ACCEPT -m comment --comment ${funcname}_dmznetforward1"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_dmznetforward1" || iptables -t filter ${ruleaddoverinsert} ${IPTABLE}
    log_debug "${IPTABLE}"
    IPTABLE="FORWARD -i ${waninf} -o ${laninf} -m state --state ESTABLISHED,RELATED -j ACCEPT -m comment --comment ${funcname}_dmznetforward2"
    iptables -t filter -S | grep "${funcname}_dmznetforward2" || iptables -t filter ${ruleaddoverinsert} ${IPTABLE}
    # dmz filter forward host
    IPTABLE="FORWARD -p ALL -i ${waninf} -o ${laninf} -d ${dmzip} -j ACCEPT -m comment --comment ${funcname}_dmzhostforward"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_dmzhostforward" || iptables -t filter ${ruleaddoverinsert} ${IPTABLE}
    # nat rule
    IPTABLE="PREROUTING -p ALL -i ${waninf} -j DNAT --to-destination ${dmzip} -m comment --comment ${funcname}_dmznat"
    log_debug "${IPTABLE}"
    iptables -t nat -S | grep "${funcname}_dmznat" || iptables -t nat ${ruleaddoverinsert} ${IPTABLE}
}

## \function NAT Prerouting/Postrouting Port forward
## \function-description Forward external ports to internal hosts and ports using NAT DNAT/SNAT rules.<br/>
## (config)```IPTABLES_PORTFORWARD="8090:192.168.79.11:8090,8010:192.168.79.12:8010"```<br/>
## (command)```iptables -t nat -A PREROUTING -p tcp --dst ${wanip} --dport ${wanport} -j DNAT --to-destination ${lanip}:${lanport} -m comment --comment ${funcname}_pre```<br/>
function __net-iptables_nat_ext_both_portforward {
    local pforwards funcname wanip wanport lanip lanport
    funcname="neb_portforward"
    pforwards=${IPTABLES_PORTFORWARD}
    wanip=$(_get_ip_of_infmark "WAN" || echo "")
    
    [[ ${#pforwards} -lt 1 ]] && log_error "${funcname}: \"${pforwards}\" is not set" && return 1
    log_debug "${pforwards}"

    IFS=$',' read -d "" -ra pforw <<< "${pforwards}" # split
    for((j=0;j<${#pforw[@]};j++)){
        IFS=$':' read -d "" -ra target <<< "${pforw[j]}" # split
        wanport=${target[0]}
        lanip=${target[1]}
        lanport=$(_trim_string ${target[2]})

        [[ ${#wanip} -lt 1 ]] && log_error "${funcname}: wanip is not set" && return 1
        [[ ${#wanport} -lt 1 ]] && log_error "${funcname}: wanport is not set" && return 1
        [[ ${#lanip} -lt 1 ]] && log_error "${funcname}: lanip is not set" && return 1
        [[ ${#lanport} -lt 1 ]] && log_error "${funcname}: lanport is not set" && return 1
        IPTABLE="PREROUTING -p tcp --dst ${wanip} --dport ${wanport} -j DNAT --to-destination ${lanip}:${lanport} -m comment --comment ${funcname}_pre"
        log_debug "${IPTABLE}"
        iptables -t nat -S | grep "${funcname}_pre" || iptables -t nat -A ${IPTABLE}
        IPTABLE="POSTROUTING -p tcp --dst ${lanip} --dport ${lanport} -j SNAT --to ${wanip} -m comment --comment ${funcname}_post"
        log_debug "${IPTABLE}"
        iptables -t nat -S | grep "${funcname}_post" || iptables -t nat -I ${IPTABLE}
    }
    # iptables -t nat -F customipchain > /dev/null || iptables -t nat -N customipchain
    # iptables -t nat -A PREROUTING -i eth1 -j customipchain
    # iptables -t nat -A customipchain -p tcp -m multiport --dports 27015:27030 -j DNAT --to-destination 192.168.0.5
    # iptables -t nat -A customipchain -p udp -m udp --dport 33540 -j DNAT --to-destination 192.168.0.5
}

## \function Raw Prerouting : Drop Invalid Tcp Flag
## \function-description Drop packets with invalid TCP flag combinations in raw table prerouting chain.<br/>
## (config)```IPTABLES_INVALID_TCPFLAG=1```<br/>
## (command)```iptables -t raw -A PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -m comment --comment ${funcname}1 -j DROP```<br/>
function __net-iptables_raw_all_both_dropinvtcpflag {
    local funcname="rab_dropinvtcpflag"
    # Invalid TCP Flag packet action
    # Default: DROP
    local ITFPA="DROP"

    IPTABLE1="PREROUTING -p tcp --tcp-flags SYN,RST SYN,RST -m comment --comment ${funcname}1 -j "$ITFPA
    IPTABLE2="PREROUTING -p tcp --tcp-flags FIN,ACK FIN -m comment --comment ${funcname}2 -j "$ITFPA
    IPTABLE3="PREROUTING -p tcp --tcp-flags ACK,URG URG -m comment --comment ${funcname}3 -j "$ITFPA
    IPTABLE4="PREROUTING -p tcp --tcp-flags ACK,FIN FIN -m comment --comment ${funcname}4 -j "$ITFPA
    IPTABLE5="PREROUTING -p tcp --tcp-flags ACK,PSH PSH -m comment --comment ${funcname}5 -j "$ITFPA
    IPTABLE6="PREROUTING -p tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG NONE -m comment --comment ${funcname}6 -j "$ITFPA
    IPTABLE7="PREROUTING -p tcp --tcp-flags FIN,SYN,RST,PSH,ACK,URG FIN,SYN,RST,PSH,ACK,URG -m comment --comment ${funcname}7 -j "$ITFPA

    iptables -t raw -S | grep "${funcname}1" || iptables -t raw -A ${IPTABLE1}
    iptables -t raw -S | grep "${funcname}2" || iptables -t raw -A ${IPTABLE2}
    iptables -t raw -S | grep "${funcname}3" || iptables -t raw -A ${IPTABLE3}
    iptables -t raw -S | grep "${funcname}4" || iptables -t raw -A ${IPTABLE4}
    iptables -t raw -S | grep "${funcname}5" || iptables -t raw -A ${IPTABLE5}
    iptables -t raw -S | grep "${funcname}6" || iptables -t raw -A ${IPTABLE6}
    iptables -t raw -S | grep "${funcname}7" || iptables -t raw -A ${IPTABLE7}
}

## \function Filter Input : Drop IPs from blacklist
## \function-description Download and block IP addresses from blacklist URLs using ipset.<br/>
## (config)```IPTABLES_BLACK_NAMELIST="url|url"```<br/>
## (command)```iptables -I INPUT -m set --match-set ${blist_name} src -j DROP```<br/>
function __net-iptables_filter_all_both_ipblacklist {
    local funcname="fab_ipblacklist"
    local blockurls filename_with_suffix filename #"https://raw.githubusercontent.com/stamparm/ipsum/master/ipsum.txt"
    blockurls=$(_trim_string "${IPTABLES_BLACK_NAMELIST}")
    [[ ${#blockurls} -lt 1 ]] && log_error "${funcname}: blockurls is not set" && return 1
    IFS=$'|' read -d "" -ra blist_url <<< "${blockurls}" # split
    local urlcount=$(echo "${blockurls}" | grep -o "|" | wc -l)
    for((j=0;j<=${urlcount};j++)){
        filename_with_suffix=${urlcount[j]##*/} # Extracts "file.html?param=value#fragment"
        filename=${filename_with_suffix%%[?#]*} # Removes query and fragment, resulting in "file.html"
        local blist_name="bl$j_$filename"
        ipset -q flush "${blist_name}"
        ipset -q create "${blist_name}" hash:net
        for ip in $(curl --compressed "${blist_url[j]}" 2>/dev/null | grep -v "#" | grep -v -E "\s[1-2]$" | cut -f 1); do ipset add "${blist_name}" "$ip"; done
        iptables -D INPUT -m set --match-set "${blist_name}" src -j DROP 2>/dev/null
        iptables -I INPUT -m set --match-set "${blist_name}" src -j DROP
    }
    ipset save > /etc/iptables/ipset.conf
}

## \function Filter Table : Base Setup (policies, loopback, established connections)
## \function-description Set up basic filter table policies, loopback rules, and connection state tracking.<br/>
## (config)```IPTABLES_ENABLE_BASE=1```<br/>
## (command)```iptables -P INPUT DROP && iptables -A INPUT -i lo -m comment --comment ${funcname}_loopback_v4 -j ACCEPT```<br/>
function __net-iptables_filter_all_both_basesetup {
    local funcname="fab_basesetup"
    log_debug "Setting up base filter table policies and loopback rules..."

    [[ ${IPTABLES_ENABLE_BASE:-1} -ne 1 ]] && return 0

    # Set base policies
    iptables -P INPUT DROP
    iptables -P FORWARD DROP  
    iptables -P OUTPUT ACCEPT
    
    # IPv6 equivalent
    # ip6tables -P INPUT DROP
    # ip6tables -P FORWARD DROP
    # ip6tables -P OUTPUT ACCEPT

    # Only setup NAT table for IPv4
    # Set NAT policies
    iptables -t nat -P PREROUTING ACCEPT
    iptables -t nat -P POSTROUTING ACCEPT
    iptables -t nat -P OUTPUT ACCEPT

    # Allow loopback traffic
    IPTABLE="INPUT -i lo -m comment --comment ${funcname}_loopback_v4 -j ACCEPT"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_loopback_v4" || iptables -t filter -A ${IPTABLE}
    # IPTABLE="INPUT -i lo -m comment --comment ${funcname}_loopback_v6 -j ACCEPT"
    # ip6tables -t filter -S | grep "${funcname}_loopback_v6" || ip6tables -t filter -A ${IPTABLE}

    # Allow established and related connections
    IPTABLE="INPUT -m conntrack --ctstate RELATED,ESTABLISHED -m comment --comment ${funcname}_established_v4 -j ACCEPT"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_established_v4" || iptables -t filter -A ${IPTABLE}
    # IPTABLE="INPUT -m conntrack --ctstate RELATED,ESTABLISHED -m comment --comment ${funcname}_established_v6 -j ACCEPT"
    # ip6tables -t filter -S | grep "${funcname}_established_v6" || ip6tables -t filter -A ${IPTABLE}

    # Drop invalid packets
    IPTABLE="INPUT -m conntrack --ctstate INVALID -m comment --comment ${funcname}_invalid_v4 -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_invalid_v4" || iptables -t filter -A ${IPTABLE}
    # IPTABLE="INPUT -m conntrack --ctstate INVALID -m comment --comment ${funcname}_invalid_v6 -j DROP"
    # ip6tables -t filter -S | grep "${funcname}_invalid_v6" || ip6tables -t filter -A ${IPTABLE}
}

## \function Filter Input : Anti-spoofing protection
## \function-description Block packets claiming to be from loopback but coming from external interfaces.<br/>
## (config)```IPTABLES_ANTISPOOFING=1```<br/>
## (command)```iptables -A INPUT -s 127.0.0.0/8 ! -i lo -m comment --comment ${funcname}_block_fake_loopback_v4 -j DROP```<br/>
function __net-iptables_filter_all_both_antispoofing {
    local funcname="fab_antispoofing"
    log_debug "Setting up anti-spoofing protection..."

    # Block remote packets claiming to be from loopback
    IPTABLE="INPUT -s 127.0.0.0/8 ! -i lo -m comment --comment ${funcname}_block_fake_loopback_v4 -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_block_fake_loopback_v4" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -s ::1/128 ! -i lo -m comment --comment ${funcname}_block_fake_loopback_v6 -j DROP"
    log_debug "${IPTABLE}"
    ip6tables -t filter -S | grep "${funcname}_block_fake_loopback_v6" || ip6tables -t filter -A ${IPTABLE}
}

## \function Filter Input : Drop broadcast/multicast/anycast packets
## \function-description Drop broadcast, multicast, and anycast packets to reduce network noise.<br/>
## (config)```IPTABLES_DROPCASTS=1```<br/>
## (command)```iptables -A INPUT -m addrtype --dst-type BROADCAST -m comment --comment ${funcname}_drop_broadcast -j DROP```<br/>
function __net-iptables_filter_all_both_dropcasts {
    local funcname="fab_dropcasts"
    log_debug "Setting up drop casts rules..."

    # Drop broadcast/multicast/anycast (IPv4 only)
    IPTABLE="INPUT -m addrtype --dst-type BROADCAST -m comment --comment ${funcname}_drop_broadcast -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_drop_broadcast" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -m addrtype --dst-type MULTICAST -m comment --comment ${funcname}_drop_multicast -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_drop_multicast" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -m addrtype --dst-type ANYCAST -m comment --comment ${funcname}_drop_anycast -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_drop_anycast" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -d 224.0.0.0/4 -m comment --comment ${funcname}_drop_multicast_range -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_drop_multicast_range" || iptables -t filter -A ${IPTABLE}
}

## \function Filter Input : drop ICMP packets
## \function-description Allow specific ICMP types for proper network operation while blocking others.<br/>
## (config)```IPTABLES_DROPICMP=1```<br/>
## (command)```iptables -A INPUT -p icmp --icmp-type 0 -m conntrack --ctstate NEW -m comment --comment ${funcname}_echo_reply -j ACCEPT```<br/>
function __net-iptables_filter_all_both_dropicmp {
    local funcname="fab_icmprules"
    
    log_debug "Setting up ICMP rules..."
    # IPv4 ICMP rules
    IPTABLE="INPUT -p icmp --icmp-type 0 -m conntrack --ctstate NEW -m comment --comment ${funcname}_echo_reply -j ACCEPT"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_echo_reply" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -p icmp --icmp-type 3 -m conntrack --ctstate NEW -m comment --comment ${funcname}_dest_unreachable -j ACCEPT"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_dest_unreachable" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -p icmp --icmp-type 8 -m conntrack --ctstate NEW -m comment --comment ${funcname}_echo_request -j ACCEPT"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_echo_request" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -p icmp --icmp-type 11 -m conntrack --ctstate NEW -m comment --comment ${funcname}_time_exceeded -j ACCEPT"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_time_exceeded" || iptables -t filter -A ${IPTABLE}

    # IPv6 ICMP rules (RFC 4890 compliant)
    # local icmpv6_types=(1 2 3 4 133 134 135 136 137 141 142 148 149)
    # for type in "${icmpv6_types[@]}"; do
    #     IPTABLE="INPUT -p ipv6-icmp --icmpv6-type ${type} -m comment --comment ${funcname}_icmpv6_${type} -j ACCEPT"
    #     ip6tables -t filter -S | grep "${funcname}_icmpv6_${type}" || ip6tables -t filter -A ${IPTABLE}
    # done

    # IPv6 link-local ICMP rules
    # local icmpv6_link_types=(130 131 132 143 151 152 153)
    # for type in "${icmpv6_link_types[@]}"; do
    #     IPTABLE="INPUT -s fe80::/10 -p ipv6-icmp --icmpv6-type ${type} -m comment --comment ${funcname}_icmpv6_link_${type} -j ACCEPT"
    #     ip6tables -t filter -S | grep "${funcname}_icmpv6_link_${type}" || ip6tables -t filter -A ${IPTABLE}
    # done
}

## \function Filter Input : Service-specific rules
## \function-description Allow incoming connections on specified ports for services.<br/>
## (config)```IPTABLES_ALLOWED_PORTS="80,443,8080"```<br/>
## (command)```iptables -A INPUT -p tcp --dport ${port} --syn -m conntrack --ctstate NEW -m comment --comment ${funcname}_custom_${port}_v4 -j ACCEPT```<br/>
function __net-iptables_filter_all_both_servicerules {
    local funcname="fab_servicerules"
    log_debug "Setting up service-specific rules..."

    # Custom ports from IPTABLES_ALLOWED_PORTS variable
    local allowed_ports=$(_trim_string "${IPTABLES_ALLOWED_PORTS}")
    [[ ${#allowed_ports} -lt 1 ]] && return 0
    
    IFS=',' read -ra ports <<< "${allowed_ports}"
    for port in "${ports[@]}"; do
        port=$(echo "$port" | xargs) # trim whitespace
        [[ $port =~ ^[0-9]+$ ]] && {
            IPTABLE="INPUT -p tcp --dport ${port} --syn -m conntrack --ctstate NEW -m comment --comment ${funcname}_custom_${port}_v4 -j ACCEPT"
            log_debug "${IPTABLE}"
            iptables -t filter -S | grep "${funcname}_custom_${port}_v4" || iptables -t filter -A ${IPTABLE}
            # IPTABLE="INPUT -p tcp --dport ${port} --syn -m conntrack --ctstate NEW -m comment --comment ${funcname}_custom_${port}_v6 -j ACCEPT"
            # ip6tables -t filter -S | grep "${funcname}_custom_${port}_v6" || ip6tables -t filter -A ${IPTABLE}
        }
    done
}

## \function Filter Input : Service-specific rules
## \function-description Allow incoming connections on specified ports for services.<br/>
## (config)```***_PORTS="LO:19283,LO:19282,LAN:20392"```<br/>
## (command)```iptables -A INPUT -p tcp --dport ${port} --syn -m conntrack --ctstate NEW -m comment --comment ${funcname}_custom_${port}_v4 -j ACCEPT```<br/>
function __net-iptables_nat_ext_both_allowedportinf {
    local funcname aportsinfs
    funcname="neb_allowedportinf"
    aportsinfs=$(_trim_string "$1")
    [[ ${#aportsinfs} -lt 1 ]] && log_error "${funcname}: \"${aportsinfs}\" is not set" && return 1
    log_debug "${aportsinfs}"
    IFS=$',' read -d "" -ra aportinf <<< "${aportsinfs}" # split
    for((j=0;j<${#aportinf[@]};j++)){
        IFS=$':' read -d "" -ra target <<< "${aportinf[j]}" # split
        dinf=$(_get_inf_of_infmark "${target[0]}" || echo "")
        dip=$(_get_ip_of_infmark "${target[0]}" || echo "")
        dport=$(_trim_string "${target[1]}")

        [[ ${#dinf} -lt 1 ]] && log_error "${funcname}: dinf is not set" && return 1
        [[ ${#dip} -lt 1 ]] && log_error "${funcname}: dip is not set" && return 1
        [[ ${#dport} -lt 1 ]] && log_error "${funcname}: dport is not set" && return 1
        
        port=$(echo "$dport" | xargs) # trim whitespace
        [[ $port =~ ^[0-9]+$ ]] && {
            IPTABLE="INPUT -i ${dinf} -d ${dip} -p tcp --dport ${dport} --syn -m conntrack --ctstate NEW -m comment --comment ${funcname}_${dinf}_${dport} -j ACCEPT"
            log_debug "${IPTABLE}"
            iptables -t filter -S | grep "{funcname}_${dinf}_${dport}" || iptables -t filter -A ${IPTABLE}
        }
    }
}

## \function Filter Input : Noise reduction rules (Drop without logging)
## \function-description Drop common network noise packets (SMB, NetBIOS) without logging to reduce log spam.<br/>
## (config)```IPTABLES_NOISE_REDUCTION=1```<br/>
## (command)```iptables -A INPUT -p udp -m multiport --dports 135,445 -m comment --comment ${funcname}_smb_udp_v4 -j DROP```<br/>
function __net-iptables_filter_all_both_noisereduction {
    local funcname="fab_noisereduction"
    log_debug "Setting up noise reduction rules..."

    # Drop SMB/Windows sharing packets without logging
    IPTABLE="INPUT -p udp -m multiport --dports 135,445 -m comment --comment ${funcname}_smb_udp_v4 -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_smb_udp_v4" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -p udp --dport 137:139 -m comment --comment ${funcname}_netbios_v4 -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_netbios_v4" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -p udp --sport 137 --dport 1024:65535 -m comment --comment ${funcname}_netbios_reply_v4 -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_netbios_reply_v4" || iptables -t filter -A ${IPTABLE}
    IPTABLE="INPUT -p tcp -m multiport --dports 135,139,445 -m comment --comment ${funcname}_smb_tcp_v4 -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_smb_tcp_v4" || iptables -t filter -A ${IPTABLE}
    # IPv6 equivalent
    # IPTABLE="INPUT -p udp -m multiport --dports 135,445 -m comment --comment ${funcname}_smb_udp_v6 -j DROP"
    # ip6tables -t filter -S | grep "${funcname}_smb_udp_v6" || ip6tables -t filter -A ${IPTABLE}
    # IPTABLE="INPUT -p udp --dport 137:139 -m comment --comment ${funcname}_netbios_v6 -j DROP"
    # ip6tables -t filter -S | grep "${funcname}_netbios_v6" || ip6tables -t filter -A ${IPTABLE}
    # IPTABLE="INPUT -p udp --sport 137 --dport 1024:65535 -m comment --comment ${funcname}_netbios_reply_v6 -j DROP"
    # ip6tables -t filter -S | grep "${funcname}_netbios_reply_v6" || ip6tables -t filter -A ${IPTABLE}
    # IPTABLE="INPUT -p tcp -m multiport --dports 135,139,445 -m comment --comment ${funcname}_smb_tcp_v6 -j DROP"
    # ip6tables -t filter -S | grep "${funcname}_smb_tcp_v6" || ip6tables -t filter -A ${IPTABLE}
}

## \function Filter Input : Drop UPnP packets
## \function-description Drop UPnP discovery packets to prevent unwanted service discovery.<br/>
## (config)```IPTABLES_DROP_UPNP=1```<br/>
## (command)```iptables -A INPUT -p udp --dport 1900 -m comment --comment ${funcname}_upnp_v4 -j DROP```<br/>
function __net-iptables_filter_all_both_dropupnp {
    local funcname="fab_dropupnp"
    log_debug "Setting up UPnP drop rules..."

    # Drop UPnP packets
    IPTABLE="INPUT -p udp --dport 1900 -m comment --comment ${funcname}_upnp_v4 -j DROP"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_upnp_v4" || iptables -t filter -A ${IPTABLE}
    # IPTABLE="INPUT -p udp --dport 1900 -m comment --comment ${funcname}_upnp_v6 -j DROP"
    # ip6tables -t filter -S | grep "${funcname}_upnp_v6" || ip6tables -t filter -A ${IPTABLE}
}

## \function Filter Input : Reject AUTH traffic quickly
## \function-description Quickly reject AUTH (ident) service requests to speed up connections.<br/>
## (config)```IPTABLES_REJECT_AUTH=1```<br/>
## (command)```iptables -A INPUT -p tcp --dport 113 --syn -m conntrack --ctstate NEW -m comment --comment ${funcname}_auth_v4 -j REJECT --reject-with tcp-reset```<br/>
function __net-iptables_filter_all_both_rejectauth {
    local funcname="fab_rejectauth"
    log_debug "Setting up AUTH reject rules..."

    # Reject AUTH traffic quickly
    IPTABLE="INPUT -p tcp --dport 113 --syn -m conntrack --ctstate NEW -m comment --comment ${funcname}_auth_v4 -j REJECT --reject-with tcp-reset"
    log_debug "${IPTABLE}"
    iptables -t filter -S | grep "${funcname}_auth_v4" || iptables -t filter -A ${IPTABLE}
    # IPTABLE="INPUT -p tcp --dport 113 --syn -m conntrack --ctstate NEW -m comment --comment ${funcname}_auth_v6 -j REJECT --reject-with tcp-reset"
    # ip6tables -t filter -S | grep "${funcname}_auth_v6" || ip6tables -t filter -A ${IPTABLE}
}

## \function NAT Prerouting : Port redirection
## \function-description Redirect incoming connections from one port to another on the same host.<br/>
## (config)```IPTABLES_PORT_REDIRECT="21:2121,8080:80" IPTABLES_REDIRECT_INTERFACE="eth0"```<br/>
## (command)```iptables -t nat -A PREROUTING -i ${interface} -p tcp --dport ${from_port} -m comment --comment ${funcname}_${from_port}_${to_port} -j REDIRECT --to-port ${to_port}```<br/>
function __net-iptables_nat_ext_both_portredirect {
    local funcname="neb_portredirect"
    local port_redirect interface
    port_redirect=$(_trim_string "${IPTABLES_PORT_REDIRECT}")
    interface=$(_trim_string "${IPTABLES_REDIRECT_INTERFACE:-eth0}")
    
    [[ ${#port_redirect} -lt 1 ]] && return 0
    [[ ${#interface} -lt 1 ]] && log_error "${funcname}: interface is not set" && return 1

    log_debug "Setting up port redirects: ${port_redirect} on ${interface}..."

    IFS=',' read -ra redirects <<< "${port_redirect}"
    for redirect in "${redirects[@]}"; do
        redirect=$(echo "$redirect" | xargs) # trim whitespace
        IFS=':' read -ra ports <<< "$redirect"
        [[ ${#ports[@]} -eq 2 ]] && {
            local from_port=${ports[0]}
            local to_port=${ports[1]}
            [[ $from_port =~ ^[0-9]+$ && $to_port =~ ^[0-9]+$ ]] && {
                IPTABLE="PREROUTING -i ${interface} -p tcp --dport ${from_port} -m comment --comment ${funcname}_${from_port}_${to_port} -j REDIRECT --to-port ${to_port}"
                log_debug "${IPTABLE}"
                iptables -t nat -S | grep "${funcname}_${from_port}_${to_port}" || iptables -t nat -A ${IPTABLE}
            }
        }
    done
}

## \function NAT Prerouting : DNAT port forwarding
## \function-description Forward external ports to internal hosts using DNAT (Destination NAT).<br/>
## (config)```IPTABLES_PORT_FORWARD="8080:192.168.1.10:80,9090:192.168.1.11:90" IPTABLES_FORWARD_INTERFACE="eth0"```<br/>
## (command)```iptables -t nat -A PREROUTING -i ${interface} -p tcp --dport ${external_port} -m comment --comment ${funcname}_${external_port}_${internal_ip}_${internal_port} -j DNAT --to-destination ${internal_ip}:${internal_port}```<br/>
function __net-iptables_nat_ext_both_portforwardsingle {
    local funcname="neb_portforwardsingle"
    local port_forward interface
    port_forward=$(_trim_string "${IPTABLES_PORT_FORWARD}")
    interface=$(_trim_string "${IPTABLES_FORWARD_INTERFACE:-eth0}")

    [[ ${#port_forward} -lt 1 ]] && return 0
    [[ ${#interface} -lt 1 ]] && log_error "${funcname}: interface is not set" && return 1

    log_debug "Setting up port forwards: ${port_forward}..."

    IFS=',' read -ra forwards <<< "${port_forward}"
    for forward in "${forwards[@]}"; do
        forward=$(echo "$forward" | xargs) # trim whitespace
        IFS=':' read -ra parts <<< "$forward"
        [[ ${#parts[@]} -eq 3 ]] && {
            local external_port=${parts[0]}
            local internal_ip=${parts[1]}
            local internal_port=${parts[2]}
            [[ $external_port =~ ^[0-9]+$ && $internal_port =~ ^[0-9]+$ ]] && {
                IPTABLE="PREROUTING -i ${interface} -p tcp --dport ${external_port} -m comment --comment ${funcname}_${external_port}_${internal_ip}_${internal_port} -j DNAT --to-destination ${internal_ip}:${internal_port}"
                log_debug "${IPTABLE}"
                iptables -t nat -S | grep "${funcname}_${external_port}_${internal_ip}_${internal_port}" || iptables -t nat -A ${IPTABLE}
            }
        }
    done
}
