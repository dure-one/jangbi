## \brief netplan network configurations. <div style="text-align: right"> group:**net** | runtype:**systemd** | deps: **os-systemd** | port: **-**</div><br/>
## \desc 
## [Netplan](https://netplan.io/){:target="_blank"} provides modern Ubuntu/Debian network management with YAML configuration files.
# It provides automated installation, configuration management, and network service control capabilities.
# Netplan uses YAML configuration files to define network interfaces, bridges, bonds, and VLANs
# with backend support for NetworkManager and systemd-networkd.
## 
## # Jangbi Configs
## ```bash title="/opt/jangbi/.config"
## RUN_NET_NETPLAN=1 # enable netplan network management
## ```
## # Check if running
## ```bash title="bash command"
## $ netplan status
## ● 1: lo ethernet UNKNOWN/UP (unmanaged)
## ● 2: eth0 ethernet UP (networkd: eth0)
## $ systemctl status systemd-networkd
## ● systemd-networkd.service - Network Service
##    Active: active (running)
## ```
## # Current Configuration
## Current configuration is stored in `/etc/netplan/`. it is generated by `net-netplan configgen` command on install.
## You can edit it manually and not run install or configapply commands to keep current configurations.
## ```bash title="/etc/netplan/01-netcfg.yaml"
## ```

# shellcheck shell=bash
cite about-plugin
about-plugin 'netplan install configurations.'

function net-netplan {
  about 'netplan install configurations'
  group 'net'
  runtype 'systemd'
  deps  'os-systemd'
  param '1: command'
  param '2: params'
  example '$ net-netplan subcommand'
  local PKGNAME="netplan"
  local DMNNAME="net-netplan"
  BASH_IT_LOG_PREFIX="net-netplan: "
  # NETPLAN_PORTS="${NETPLAN_PORTS:-""}"
  if _check_config_reload; then
      _load_config
      _root_only
      _distname_check
  fi

  if [[ $# -eq 1 ]] && [[ "$1" = "help" ]]; then
    __net-netplan_help "$2"
  elif [[ $# -eq 1 ]] && [[ "$1" = "install" ]]; then
    __net-netplan_install "$2"
  elif [[ $# -eq 1 ]] && [[ "$1" = "uninstall" ]]; then
    __net-netplan_uninstall "$2"
  elif [[ $# -eq 1 ]] && [[ "$1" = "download" ]]; then
    __net-netplan_download "$2"
  elif [[ $# -eq 1 ]] && [[ "$1" = "disable" ]]; then
    __net-netplan_disable "$2"
  elif [[ $# -eq 1 ]] && [[ "$1" = "configgen" ]]; then
    __net-netplan_configgen "$2"
  elif [[ $# -eq 1 ]] && [[ "$1" = "configapply" ]]; then
    __net-netplan_configapply "$2"
  elif [[ $# -eq 1 ]] && [[ "$1" = "check" ]]; then
    __net-netplan_check "$2"
  elif [[ $# -eq 1 ]] && [[ "$1" = "run" ]]; then
    __net-netplan_run "$2"
  else
    __net-netplan_help
  fi
}

## \usage net-netplan help|install|uninstall|download|disable|configgen|configapply|check|run
## $ net-netplan install - install netplan network management
## $ net-netplan uninstall - uninstall netplan
## $ net-netplan download - download netplan package files to pkg dir
## $ net-netplan disable - disable netplan plugin
## $ net-netplan configgen - generate netplan configuration files
## $ net-netplan configapply - apply netplan configuration files
## $ net-netplan check - check netplan plugin status
## $ net-netplan run - run netplan network services
## $ net-netplan help - show this help message
function __net-netplan_help {
  echo -e "Usage: net-netplan [COMMAND]\n"
  echo -e "Helper to netplan install configurations.\n"
  echo -e "Commands:\n"
  echo "   help                       Show this help message"
  echo "   install                    Install netplan"
  echo "   uninstall                  Uninstall installed netplan"
  echo "   download                   Download pkg files to pkg dir"
  echo "   disable                    Disable netplan service"
  echo "   configgen                  Configs Generator"
  echo "   configapply                Apply Configs"
  echo "   check                      Check vars available"
  echo "   run                        do task at bootup"
}

function __net-netplan_install {
  log_debug "Installing ${DMNNAME}..."
  export DEBIAN_FRONTEND=noninteractive
  if [[ ${INTERNET_AVAIL} -gt 0 ]]; then
      [[ $(find /etc/apt/sources.list.d|grep -c "extrepo_debian_official") -lt 1 ]] && extrepo enable debian_official
      [[ $(stat /var/lib/apt/lists -c "%X") -lt $(date -d "1 day ago" +%s) ]] && apt update -qy
      apt install -qy netplan.io iproute2 || log_error "${DMNNAME} online install failed."
  else
      local filepat="./pkgs/${PKGNAME}*.deb"
      local pkglist="./pkgs/${PKGNAME}.pkgs"
      [[ $(find ${filepat}|wc -l) -lt 1 ]] && log_error "${DMNNAME} pkg file not found."
      pkgslist_down=()
      while read -r pkg; do
          [[ $pkg ]] && pkgslist_down+=("./pkgs/${pkg}*.deb")
      done < ${pkglist}
      # shellcheck disable=SC2068
        apt install -qy ${pkgslist_down[@]} || log_error "${DMNNAME} offline install failed."
  fi
  if ! __net-netplan_configgen; then # if gen config is different do apply
      __net-netplan_configapply
      rm -rf /tmp/netplan
  fi
}

function __net-netplan_configgen { # config generator and diff
  log_debug "Generating config for ${DMNNAME}..."
  rm -rf /tmp/${PKGNAME} 1>/dev/null 2>&1
  mkdir -p /tmp/${PKGNAME} /etc/${PKGNAME} 1>/dev/null 2>&1
  __net-netplan_build
  # diff check
  diff -Naur /etc/${PKGNAME} /tmp/${PKGNAME} > /tmp/${PKGNAME}.diff
  [[ $(stat -c %s /tmp/${PKGNAME}.diff) = 0 ]] && return 0 || return 1
}

function __net-knetplan_configapply {
  [[ ! -f /tmp/${PKGNAME}.diff ]] && log_error "/tmp/${PKGNAME}.diff file doesnt exist. please run configgen."
  log_debug "Applying config ${DMNNAME}..."
  local dtnow=$(date +%Y%m%d_%H%M%S)
  [[ -d "/etc/${PKGNAME}" ]] && cp -rf "/etc/${PKGNAME}" "/etc/.${PKGNAME}.${dtnow}"
  pushd /etc/${PKGNAME} 1>/dev/null 2>&1
  patch -i /tmp/${PKGNAME}.diff
  popd 1>/dev/null 2>&1
  rm /tmp/${PKGNAME}.diff
  return 0
}

function __net-netplan_download {
  log_debug "Downloading ${DMNNAME}..."
  _download_apt_pkgs "netplan.io iproute2" || log_error "${DMNNAME} download failed."
  return 0
}

function __net-netplan_build { 
    if [[ -n ${JB_NETPLAN} ]]; then # custom netplan exists
        echo "${JB_NETPLAN}" > /tmp/netplan/dure_network.yaml
        chmod 600 /tmp/netplan/dure_network.yaml 1>/dev/null 2>&1
        return
    fi

    # Initialize YAML structure
    tee /tmp/netplan/dure_network.yaml > /dev/null <<EOT
network:
  version: 2
  renderer: networkd
  ethernets:
EOT

    local waninf=${JB_WANINF} laninf=${JB_LANINF} wlaninf=${JB_WLANINF}

    # Auto-select interfaces if not defined
    if [[ -z ${waninf} && -z ${laninf} && -z ${wlaninf} ]]; then
        local dure_infs=($(cat /proc/net/dev | awk '{ print $1 }' | grep : | grep -v lo: | sed 's/:$//'))
        
        for inf in "${dure_infs[@]}"; do
            [[ ! ${waninf} && ${inf:0:1} != 'w' && ${inf} != "${laninf}" && ${inf} != "${wlaninf}" ]] && waninf=${inf} && continue
            [[ ! ${laninf} && ${inf:0:1} != 'w' && ${inf} != "${waninf}" && ${inf} != "${wlaninf}" ]] && laninf=${inf} && continue
            [[ ! ${wlaninf} && ${inf:0:1} == 'w' && ${inf} != "${laninf}" && ${inf} != "${waninf}" ]] && wlaninf=${inf} && continue
        done

        sed -i "s|JB_WANINF=.*|JB_WANINF=${waninf}|g" "${JB_DEPLOY_PATH}/.config"
        [[ -z ${JB_WAN} ]] && sed -i "s|JB_WAN=.*|JB_WAN=\"dhcp\"|g" "${JB_DEPLOY_PATH}/.config"
        sed -i "s|JB_LANINF=.*|JB_LANINF=${laninf}|g" "${JB_DEPLOY_PATH}/.config"
        [[ -z ${JB_LAN} ]] && sed -i "s|JB_LAN=.*|JB_LAN=\"192.168.1.1/24\"|g" "${JB_DEPLOY_PATH}/.config"
        sed -i "s|JB_WLANINF=.*|JB_WLANINF=${wlaninf}|g" "${JB_DEPLOY_PATH}/.config"
        [[ -z ${JB_WLAN} ]] && sed -i "s|JB_WLAN=.*|JB_WLAN=\"192.168.100.1/24\"|g" "${JB_DEPLOY_PATH}/.config"
        [[ -z ${JB_WLAN_SSID} ]] && sed -i "s|JB_WLAN_SSID=.*|JB_WLAN_SSID=\"durejangbi\"|g" "${JB_DEPLOY_PATH}/.config"
        [[ -z ${JB_WLAN_PASS} ]] && sed -i "s|JB_WLAN=.*|JB_WLAN=\"durejangbi\"|g" "${JB_DEPLOY_PATH}/.config"
    fi

    # Helper function to generate ethernet interface config
    _generate_ethernet_config() {
        local inf_name=$1 ip_var=$2 gw_var=$3 inf_type=${4:-"lan"}
        
        if [[ -z ${!ip_var} || ${!ip_var,,} == "dhcp" ]]; then
            tee -a /tmp/netplan/dure_network.yaml > /dev/null <<EOT
    ${inf_name}:
      dhcp4: true
EOT
            return
        fi

        # Static IP configuration
        local routes_section=""
        if [[ -n ${!gw_var} ]]; then
            routes_section="
      routes:
        - to: 0.0.0.0/0
          via: ${!gw_var}"
        elif [[ ${inf_type} == "wan" ]]; then
            local gw=$(ipcalc-ng "${!ip_var}" | grep HostMin: | cut -f2)
            routes_section="
      routes:
        - to: 0.0.0.0/0
          via: ${gw}"
        fi

        tee -a /tmp/netplan/dure_network.yaml > /dev/null <<EOT
    ${inf_name}:
      dhcp4: false
      addresses: [${!ip_var}]${routes_section}
EOT
    }

    # Helper function to generate wifi config
    _generate_wifi_config() {
        local inf_name=$1 ip_var=$2 gw_var=$3
        
        if [[ -z ${!ip_var} || ${!ip_var,,} == "dhcp" ]]; then
            tee -a /tmp/netplan/dure_network.yaml > /dev/null <<EOT
  wifis:
    ${inf_name}:
      access-points:
        "${JB_WLAN_SSID}":
          password: "${JB_WLAN_PASS}"
      dhcp4: yes
EOT
            return
        fi

        # Static wifi configuration
        local routes_section=""
        [[ -n ${!gw_var} ]] && routes_section="
      routes:
        - to: 0.0.0.0/0
          via: ${!gw_var}"

        tee -a /tmp/netplan/dure_network.yaml > /dev/null <<EOT
  wifis:
    ${inf_name}:
      addresses: [${!ip_var}]
      access-points:
        "${JB_WLAN_SSID}":
          password: "${JB_WLAN_PASS}"
      dhcp4: no
      dhcp6: no${routes_section}
EOT
    }

    # Process all interfaces
    local dure_infs=($(cat /proc/net/dev | awk '{ print $1 }' | grep : | grep -v lo: | sed 's/:$//'))
    local wifi_processed=false
    
    for inf in "${dure_infs[@]}"; do
        case ${inf} in
            ${waninf})
                _generate_ethernet_config "${inf}" "JB_WAN" "JB_WANGW" "wan"
                ;;
            ${laninf})
                _generate_ethernet_config "${inf}" "JB_LAN" "JB_LANGW" "lan"
                ;;
            ${wlaninf})
                [[ ${wifi_processed} == false ]] && _generate_wifi_config "${inf}" "JB_WLAN" "JB_WLANGW" && wifi_processed=true
                ;;
            ${JB_LAN0INF}|${JB_LAN1INF}|${JB_LAN2INF}|${JB_LAN3INF}|${JB_LAN4INF}|${JB_LAN5INF}|${JB_LAN6INF}|${JB_LAN7INF}|${JB_LAN8INF}|${JB_LAN9INF})
                # Find matching LAN interface
                for i in {0..9}; do
                    local lan_inf_var="JB_LAN${i}INF"
                    local lan_var="JB_LAN${i}"
                    [[ ${inf} == ${!lan_inf_var} ]] && {
                        _generate_ethernet_config "${inf}" "${lan_var}" "" "lan"
                        break
                    }
                done
                ;;
            *)
                # Default DHCP for unmatched interfaces
                if [[ ${inf:0:1} != 'w' ]]; then
                    tee -a /tmp/netplan/dure_network.yaml > /dev/null <<EOT
    ${inf}:
      dhcp4: true
EOT
                elif [[ ${inf:0:1} == 'w' && ${wifi_processed} == false ]]; then
                    tee -a /tmp/netplan/dure_network.yaml > /dev/null <<EOT
    ${inf}:
      dhcp4: true
EOT
                fi
                ;;
        esac
    done

    chmod 600 /tmp/netplan/dure_network.yaml 1>/dev/null 2>&1
}

function __net-netplan_uninstall { 
  log_debug "Uninstalling ${DMNNAME}..."
  apt purge -qy netplan.io
}

function __net-netplan_disable {
  log_debug "Disabling ${DMNNAME}..."
  systemctl stop systemd-networkd
  systemctl disable systemd-networkd
  return 0
}

function __net-netplan_check { # running_status: 0 running, 1 installed, running_status 5 can install, running_status 10 can't install, 20 skip
  running_status=0
  log_debug "Checking ${DMNNAME}..."

  # check package file exists
  [[ $(find ./pkgs/${PKGNAME}*.pkgs|wc -l) -lt 1 ]] && \
      log_info "${PKGNAME} package file does not exist." && [[ $running_status -lt 15 ]] && running_status=15
  # RUN_OS_SYSTEMD 1 - full systemd, 0 - disable completely, 2 - only journald
  [[ -z ${RUN_OS_SYSTEMD} ]] && \
      log_error "RUN_OS_SYSTEMD variable is not set." && [[ $running_status -lt 10 ]] && running_status=10
  [[ ${RUN_OS_SYSTEMD} == 0 ]] && \
      log_error "RUN_OS_SYSTEMD set to disable completely(RUN_OS_SYSTEMD=0)." && [[ $running_status -lt 20 ]] && running_status=20
  [[ ${RUN_OS_SYSTEMD} == 2 ]] && \
      log_error "RUN_OS_SYSTEMD set to only journald(RUN_OS_SYSTEMD=2)." && [[ $running_status -lt 20 ]] && running_status=20
  # check package netplan
  [[ $(dpkg -l|awk '{print $2}'|grep -c "netplan") -lt 1 ]] && \
      log_info "netplan is not installed." && [[ $running_status -lt 5 ]] && running_status=5
  # check if ~~running~~ configured
  #[[ -f /etc/netplan/dure_network.yaml ]] && \
  #    log_info "netplan is configured." && [[ $running_status -lt 0 ]] && running_status=0
  # check if running
  [[ $(systemctl status systemd-networkd 2>/dev/null|awk '{ print $2 }'|grep -c inactive) -lt 1 ]] && \
      log_info "systemd-networkd is running." && [[ $running_status -lt 1 ]] && running_status=1

  return 0
}

function __net-netplan_run {
  # Cannot call openvswitch: ovsdb-server.service is not running. msg is not relevant.
  netplan apply
  systemctl status systemd-networkd && return 0 || \
        log_error "net-netplan failed to run." && return 1
  return 0
}

complete -F _blank net-netplan
