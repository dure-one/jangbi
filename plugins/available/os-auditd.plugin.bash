## \brief auditd install configurations. <div style="text-align: right"> group:**prenet** | runtype:**systemd** | deps: **-** | port: **-**</div><br/>
## \desc 
## [Auditd](https://github.com/linux-audit/audit-userspace){:target="_blank"} (Linux Audit Daemon) tracks system calls, file access, user activities, and security events.
# It provides automated installation, configuration management, and audit log monitoring capabilities.
# Auditd enables comprehensive system monitoring for forensics and compliance requirements.
## 
## # Jangbi Configs
## ```bash title="/opt/jangbi/.config"
## RUN_OS_AUDITD=1 # enable auditd system monitoring
## ```
## # Check if running
## ```bash title="bash command"
## $ systemctl status auditd
## ‚óè auditd.service - Security Auditing Service
##    Active: active (running)
## $ aureport --summary
## Summary Report
## ======================
## Range of time in logs: 01/01/2024 00:00:00.000 - 07/22/2025 12:00:00.000
## ```
## # Current Configuration
## Current configuration is stored in `/etc/audit/`. it is generated by `os-auditd configgen` command on install.
## You can edit it manually and not run install or configapply commands to keep current configurations.
## ```bash title="/etc/audit/auditd.conf"
## --8<-- "./configs/auditd/auditd.conf"
## ```

# shellcheck shell=bash
cite about-plugin
about-plugin 'auditd install configurations.'

function os-auditd {
    about 'auditd install configurations'
    group 'prenet'
    runtype 'systemd'
    deps  ''
    param '1: command'
    param '2: params'
    example '$ os-auditd subcommand'
    local PKGNAME="auditd"
    local DMNNAME="os-auditd"
    BASH_IT_LOG_PREFIX="os-auditd: "
    # AUIDITD_PORTS="${AUIDITD_PORTS:-""}"
    if _check_config_reload; then
        _root_only || exit 1
        _distname_check || exit 1
    fi

    if [[ $# -eq 1 ]] && [[ "$1" = "help" ]]; then
        __os-auditd_help "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "install" ]]; then
        __os-auditd_install "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "uninstall" ]]; then
        __os-auditd_uninstall "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "download" ]]; then
        __os-auditd_download "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "disable" ]]; then
        __os-auditd_disable "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "configgen" ]]; then
        __os-auditd_configgen "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "configapply" ]]; then
        __os-auditd_configapply "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "check" ]]; then
        __os-auditd_check "$2"
    elif [[ $# -eq 1 ]] && [[ "$1" = "run" ]]; then
        __os-auditd_run "$2"
    else
        __os-auditd_help
    fi
}

## \usage os-auditd help|install|uninstall|download|disable|configgen|configapply|check|run
## $ os-auditd install - install auditd system monitoring
## $ os-auditd uninstall - uninstall auditd
## $ os-auditd download - download auditd package files to pkg dir
## $ os-auditd disable - disable auditd plugin
## $ os-auditd configgen - generate auditd configuration files
## $ os-auditd configapply - apply auditd configuration files
## $ os-auditd check - check auditd plugin status
## $ os-auditd run - run auditd service
## $ os-auditd help - show this help message
function __os-auditd_help {
    echo -e "Usage: os-auditd [COMMAND]\n"
    echo -e "Helper to auditd install configurations.\n"
    echo -e "Commands:\n"
    echo "   help         Show this help message"
    echo "   install      Install os auditd"
    echo "   uninstall    Uninstall installed auditd"
    echo "   download     Download pkg files to pkg dir"
    echo "   disable      Disable auditd"
    echo "   configgen    Configs Generator"
    echo "   configapply  Apply Configs"
    echo "   check        Check vars available"
    echo "   run          Run tasks"
}

function __os-auditd_install {
    log_debug "Installing ${DMNNAME}..."
    export DEBIAN_FRONTEND=noninteractive
    if [[ ${INTERNET_AVAIL} -gt 0 ]]; then
        [[ $(find /etc/apt/sources.list.d|grep -c "extrepo_debian_official") -lt 1 ]] && extrepo enable debian_official
        [[ $(stat /var/lib/apt/lists -c "%X") -lt $(date -d "1 day ago" +%s) ]] && apt update -qy
        apt install -qy auditd
    else
        local filepat="./pkgs/auditd*.deb"
        local pkglist="./pkgs/auditd.pkgs"
        [[ $(find ${filepat}|wc -l) -lt 1 ]] && apt update -qy && __os-auditd_download
        pkgslist_down=()
        while read -r pkg; do
            [[ $pkg ]] && pkgslist_down+=("./pkgs/${pkg}*.deb")
        done < ${pkglist}
        # shellcheck disable=SC2068
        apt install -qy ${pkgslist_down[@]} || log_error "${DMNNAME} offline install failed."
    fi

    if ! __os-auditd_configgen; then # if gen config is different do apply
        __os-auditd_configapply
        rm -rf /tmp/${PKGNAME}
    fi
    mkdir -p /var/log/audit
}

function __os-auditd_uninstall {
    log_debug "Uninstalling ${DMNNAME}..."
    systemctl stop auditd
    systemctl disable auditd
}

function __os-auditd_download {
    log_debug "Downloading ${DMNNAME}..."
    _download_apt_pkgs auditd || log_error "${DMNNAME} download failed."
    return 0
}

function __os-auditd_disable {
    log_debug "Disabling ${DMNNAME}..."
    systemctl stop auditd
    systemctl disable auditd
    return 0
}

function __os-auditd_configgen { # config generator and diff
    log_debug "Generating config for ${DMNNAME}..."
    rm -rf /tmp/${PKGNAME} 1>/dev/null 2>&1
    mkdir -p /tmp/${PKGNAME} /etc/${PKGNAME} 1>/dev/null 2>&1
    cp ./configs/${PKGNAME}/* /tmp/${PKGNAME}/
    __os-auditd_generate_config
    diff -Naur /etc/${PKGNAME} /tmp/${PKGNAME} > /tmp/${PKGNAME}.diff
    [[ $(stat -c %s /tmp/${PKGNAME}.diff) = 0 ]] && return 0 || return 1
}

function __os-auditd_configapply {
    [[ ! -f /tmp/${PKGNAME}.diff ]] && log_error "/tmp/${PKGNAME}.diff file doesnt exist. please run configgen."
    log_debug "Applying config ${DMNNAME}..."
    local dtnow=$(date +%Y%m%d_%H%M%S)
    [[ -d "/etc/${PKGNAME}" ]] && cp -rf "/etc/${PKGNAME}" "/etc/.${PKGNAME}.${dtnow}"
    pushd /etc/${PKGNAME} 1>/dev/null 2>&1
    patch -i /tmp/${PKGNAME}.diff
    popd 1>/dev/null 2>&1
    rm /tmp/${PKGNAME}.diff
    return 0
}

function __os-auditd_check {  # running_status: 0 running, 1 installed, running_status 5 can install, running_status 10 can't install, 20 skip
    running_status=0
    log_debug "Checking ${DMNNAME}..."

    # check package file exists
    [[ $(find ./pkgs/${PKGNAME}*.pkgs|wc -l) -lt 1 ]] && \
        log_info "${PKGNAME} package file does not exist." && [[ $running_status -lt 15 ]] && running_status=15
    # check global variable
    [[ -z ${RUN_OS_AUDITD} ]] && \
        log_error "RUN_OS_AUDITD variable is not set." && [[ $running_status -lt 10 ]] && running_status=10
    [[ ${RUN_OS_AUDITD} != 1 ]] && \
        log_error "RUN_OS_AUDITD is not enabled." && __os-auditd_disable && [[ $running_status -lt 20 ]] && running_status=20
    # check package dnsmasq
    [[ $(dpkg -l|awk '{print $2}'|grep -c "auditd") -lt 1 ]] && \
        log_info "auditd is not installed." && [[ $running_status -lt 5 ]] && running_status=5
    # check if running
    [[ $(pidof auditd) -gt 0 ]] && \
        log_info "auditd is running." && [[ $running_status -lt 1 ]] && running_status=1

    return 0
}

function __os-auditd_run {
    log_debug "Running ${DMNNAME}..."
    systemctl restart auditd
    systemctl status auditd && return 0 || \
        log_error "auditd failed to run." && return 1
    return 0
}

complete -F _blank os-auditd

function __os-auditd_generate_config {
    mkdir -p /tmp/auditd
    cp -rf ./configs/auditd/audit.rules  /tmp/auditd/audit.rules
    # auditctl -R /tmp/auditd/audit.rules
    # add rules by force
    local string_with_newlines=$(cat /tmp/auditd/audit.rules|grep -v "#"|grep -v -e '^[[:space:]]*$')
    while IFS= read -r line; do
        auditctl ${line} &>/dev/null
    done <<< "$string_with_newlines"
    # check unserted lines
    echo "# generated on $(date +%s)" > /tmp/auditd/audit.rules.rejected
    while IFS= read -r line; do
        found=$(auditctl -l|grep "\\$line"|wc -l)
        [[ ${found} == 0 ]] && echo "${line}" >> /tmp/auditd/audit.rules.rejected
    done <<< "$string_with_newlines"
    # backup accepted lines
    echo "# generated on $(date +%s)" > /tmp/auditd/audit.rules
    auditctl -l >> /tmp/auditd/audit.rules
    return 0
}